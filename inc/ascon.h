/**
 * @file
 * Ascon cipher - Lightweight Authenticated Encryption & Hashing
 *
 * Ascon is a family of authenticated encryption and hashing algorithms
 * designed to be lightweight and easy to implement, even with added
 * countermeasures against side-channel attacks.
 *
 * For more information on the Ascon cipher itself, visit
 * https://ascon.iaik.tugraz.at/
 *
 * This file is the interface to the Ascon library providing:
 * - the Ascon symmetric AEAD cipher
 * - the Ascon fixed-size output hash
 * - the Ascon variable-size output hash (xof)
 *
 * All functionalities are available in:
 * - online form (init-update-final paradigm): the data is processed one
 *   chunk at the time; useful if is still being received or does not
 *   fit into memory
 * - offline form: the data is available as a whole in memory and processed
 *   in one go
 *
 * Library dependencies:
 * - only the C99 or C11 standard library, as seen in the `#include` statements
 *   below
 *
 * @license Creative Commons Zero (CC0) 1.0
 * @authors See AUTHORS.md file
 */

// TODO test all branches in the algorithm
// TODO test all NULLable parameters
// TODO static analyser
// TODO valgrind
// TODO fuzzer
// TODO tests with updates of different length (contd.)
// 1B, 2B, ... 16B
// Same but with initial offset
// Same with pseudorandom sequences like 3, 17, 9, 1, 0, 22

#ifndef ASCON_H
#define ASCON_H

#ifdef __cplusplus
extern "C"
{
#endif

#include <stdint.h> /* For uint8_t, uint64_t */
#include <stddef.h> /* For size_t, NULL */
#include <string.h> /* For memset() */

/**
 * Length in bytes of the secret symmetric key used for authenticated
 * encryption and decryption.
 */
#define ASCON_AEAD_KEY_LEN 16U

/**
 * Length in bytes of the public nonce used for authenticated
 * encryption and decryption.
 */
#define ASCON_AEAD_NONCE_LEN 16U

/**
 * Length in bytes of the authentication tag generated by the authenticated
 * encryption and validated by the decryption.
 */
#define ASCON_AEAD_TAG_LEN 16U

/**
 * Length in bytes of the digest generated by the fixed-size (non-xof) hash
 * function.
 */
#define ASCON_HASH_DIGEST_LEN 32U

/**
 * Rate in bytes at which the input data is processed by the cipher.
 *
 * The cipher can absorb only chunks of this many bytes. Any trailing bytes
 * of the processed data are padded.
 */
#define ASCON_RATE 8U

/**
 * Possible outputs of the final step of the decryption that also validates
 * the tag.
 */
typedef enum
{
    /** The tag is valid thus the decryption too. */
    ASCON_TAG_OK = 0,
    /** The tag is invalid thus the decrypted data should be ignored. */
    ASCON_TAG_INVALID = 1,
} ascon_tag_validity_t;

/**
 * Internal cipher sponge state (320 bits).
 */
typedef struct
{
    uint64_t x0;
    uint64_t x1;
    uint64_t x2;
    uint64_t x3;
    uint64_t x4;
} ascon_sponge_t;

/**
 * Internal cipher sponge state associated with a buffer holding for
 * less-than-rate updates. Used for the Init-Update-Final implementation.
 */
typedef struct
{
    /** Cipher sponge state. */
    ascon_sponge_t sponge;

    /** Counter of all encrypted/decrypted bytes, excluding associated data. */
    uint64_t total_output_len;

    /** Buffer caching the less-than-rate long input between update calls. */
    uint8_t buffer[ASCON_RATE];

    /** Currently used bytes of the buffer. */
    uint8_t buffer_len;

    /**
     * State of the processing of the associated data.
     *
     * Note: this variable is not semantically relevant in THIS struct,
     * as it should belong in the struct ascon_aead_ctx_t, but by having it
     * here we spare bytes of padding (7 on 64-bit systems, 3 on 32-bit)
     * at the end of the struct ascon_aead_ctx_t, by using the padding space
     * this struct anyway has.
     *
     * This struct has anyway some padding at the end.
     */
    uint8_t assoc_data_state;

    /** Unused padding to the next uint64_t (sponge.x0). */
    uint8_t pad[6];
} ascon_bufstate_t;

/**
 * Cipher context for authenticated encryption and validated decryption.
 *
 * Half of this context's size is the cipher's sponge state, the remaining
 * part is holding the key and the buffering of online data (and some padding).
 */
typedef struct
{
    /** Cipher buffered sponge state. */
    ascon_bufstate_t bufstate;

    /** Copy of the secret key, to be used in the final step, first half. */
    uint64_t k0;

    /** Copy of the secret key, to be used in the final step, second half. */
    uint64_t k1;
} ascon_aead_ctx_t;

/** Cipher context for hashing. */
typedef ascon_bufstate_t ascon_hash_ctx_t;

// TODO add notes that AD is optional
// TODO add notes that PT is optional but not recommended
// TODO difference between AEAD(key, nonce, ad, NO_PT) and HASH
//  (key||nonce||msg)?
/**
 * Offline symmetric encryption using Ascon128.
 *
 * Encrypts the data which is already available as a whole in a contiguous
 * buffer, authenticating any optional associated data in the process.
 * Provides the ciphertext and the authentication tag as output.
 *
 * In case of no associated data at all to be authenticated, set
 * \p assoc_data_len to 0. Iff that is the case, \p assoc_data can
 * be set to NULL.
 *
 * In case of no plaintext at all to be encrypted, set
 * \p plaintext_len to 0. Iff that is the case, \p plaintext can
 * be set to NULL.
 *
 * @warning
 * Using the AEAD encryption to just authenticate any associated data with no
 * plaintext to be encrypted is not recommended for security reasons.
 * Instead use the Ascon hashing or xof functions in the form
 * `H(key || nonce || msg)`.
 *
 * @image html encrypt.png
 *
 * @param[out] ciphertext encrypted plaintext with the same length as the
 *       plaintext, thus \p plaintext_len will be written in this buffer.
 *       This pointer may also point to the same location as \p plaintext
 *       to encrypt the plaintext in-place, sparing on memory instead
 *       of writing into a separate output buffer, not NULL.
 * @param[out] tag authentication tag of the associated data and
 *        the ciphertext of ASCON_AEAD_TAG_LEN bytes, not NULL.
 * @param[in] key secret key of ASCON_AEAD_KEY_LEN bytes.
 * @param[in] nonce public unique nonce of ASCON_AEAD_NONCE_LEN bytes.
 * @param[in] assoc_data data to be authenticated with the same tag
 *        but not encrypted. Can be NULL iff \p assoc_data_len is 0.
 * @param[in] plaintext data to be encrypted into \p ciphertext.
 * @param[in] assoc_data_len length of the data pointed by \p assoc_data in
 *        bytes. Can be 0.
 * @param[in] plaintext_len length of the data pointed by \p plaintext in
 *        bytes. Can be 0 (not recommended, use hashing to just authenticate).
 */
void ascon_aead128_encrypt(uint8_t* ciphertext,
                           uint8_t tag[ASCON_AEAD_TAG_LEN],
                           const uint8_t key[ASCON_AEAD_KEY_LEN],
                           const uint8_t nonce[ASCON_AEAD_NONCE_LEN],
                           const uint8_t* assoc_data,
                           const uint8_t* plaintext,
                           size_t assoc_data_len,
                           size_t plaintext_len);

/**
 * Online symmetric encryption using Ascon128, initialisation.
 *
 * Prepares to start a new encryption session for plaintext and associated data
 * being provided one chunk at the time, overwriting any previous content of
 * the context.
 *
 * The key and nonce are copied/absorbed into the internal state, so they can
 * be deleted from their original location after this function returns.
 *
 * The calling order is:
 * 1. init (once only)
 * 2. associated data update (0 or more times)
 * 3. encryption update (0 or more times, see warning)
 * 4. final (once only)
 *
 * @warning
 * Using the AEAD encryption to just authenticate any associated data with no
 * plaintext at all to be encrypted is not recommended for security reasons.
 * Instead use the Ascon hashing or xof functions in the form
 * `H(key || nonce || msg)`.
 *
 * @warning
 * A copy of the secret key is kept in the \p ctx struct and securely erased
 * during the ascon_aead128_encrypt_final() call. In case the encryption
 * session is interrupted and never finalised, clear the context with
 * `memset(&ctx, 0, sizeof(ascon_aead_ctx_t));` to erase the key copy.
 *
 * @param[in, out] ctx the encryption context, handling the cipher state
 *       and buffering of incoming data to be processed. Not NULL.
 * @param[in] key secret key of ASCON_AEAD_KEY_LEN bytes. Not NULL.
 * @param[in] nonce public unique nonce of ASCON_AEAD_NONCE_LEN bytes. Not NULL.
 */
void ascon_aead128_init(ascon_aead_ctx_t* ctx,
                        const uint8_t key[ASCON_AEAD_KEY_LEN],
                        const uint8_t nonce[ASCON_AEAD_NONCE_LEN]);

/**
 * Online symmetric encryption using Ascon128, feeding associated data.
 *
 * Feeds a chunk of associated data to the already initialised encryption
 * session. The data will be authenticated by the tag provided by the final
 * function, but not encrypted.
 *
 * In case of no associated data at all to be authenticated, this function
 * can either be either skipped completely or called (also many times)
 * with \p assoc_data_len set to 0. Iff that is the case, \p assoc_data can
 * be set to NULL.
 *
 * After calling ascon_aead128_encrypt_update(), this function must not be used
 * anymore.
 *
 * The calling order is:
 * 1. init (once only)
 * 2. associated data update (0 or more times)
 * 3. encryption update (0 or more times, see warning)
 * 4. final (once only)
 *
 * @warning
 * Using the AEAD encryption to just authenticate any associated data with no
 * plaintext at all to be encrypted is not recommended for security reasons.
 * Instead use the Ascon hashing or xof functions in the form
 * `H(key || nonce || msg)`.
 *
 * @param[in, out] ctx the encryption context, handling the cipher state
 *       and buffering of incoming data to be processed. Not NULL.
 * @param[in] assoc_data data to be authenticated with the same tag
 *        but not encrypted. May be NULL iff \p assoc_data_len is 0.
 * @param[in] assoc_data_len length of the data pointed by \p assoc_data in
 *        bytes. May be 0.
 */
void ascon_aead128_assoc_data_update(ascon_aead_ctx_t* ctx,
                                     const uint8_t* assoc_data,
                                     size_t assoc_data_len);

/**
 * Online symmetric encryption using Ascon128, feeding plaintext and getting
 * ciphertext.
 *
 * Feeds a chunk of plaintext data to the encryption session after any
 * optional associated data has been processed. The plaintext will be encrypted
 * and provided back in buffered chunks of #ASCON_RATE.
 *
 * It will automatically finalise the absorption of any associated data,
 * so no new associated data could be processed after this function is called.
 *
 * The calling order is:
 * 1. init (once only)
 * 2. associated data update (0 or more times)
 * 3. encryption update (0 or more times, see warning)
 * 4. final (once only)
 *
 * @warning
 * Using the AEAD encryption to just authenticate any associated data with no
 * plaintext at all to be encrypted is not recommended for security reasons.
 * Instead use the Ascon hashing or xof functions in the form
 * `H(key || nonce || msg)`.
 *
 * @param[in, out] ctx the encryption context, handling the cipher state
 *       and buffering of incoming data to be processed. Not NULL.
 * @param[out] ciphertext encrypted plaintext, buffered into chunks.
 *       This function will write a multiple of #ASCON_RATE bytes in the
 *       interval [0, \p plaintext_len] into \p ciphertext.
 *       The exact number of written bytes is indicated by the return value.
 *       This pointer may also point to the same location as \p plaintext
 *       to encrypt the plaintext in-place, sparing on memory instead
 *       of writing into a separate output buffer. Not NULL.
 * @param[in] plaintext data to be encrypted into \p ciphertext. All of the
 *       plaintext will be processed, even if the function provides less than
 *       \p plaintext_len output bytes. They are just buffered. Not NULL.
 * @param[in] plaintext_len length of the data pointed by \p plaintext in
 *        bytes. May be 0.
 * @returns number of bytes written into \p ciphertext. The value is a multiple
 *        of #ASCON_RATE in [0, \p plaintext_len].
 */
size_t ascon_aead128_encrypt_update(ascon_aead_ctx_t* ctx,
                                    uint8_t* ciphertext,
                                    const uint8_t* plaintext,
                                    size_t plaintext_len);

/**
 * Online symmetric encryption using Ascon128, finalisation and tag generation.
 *
 * Finalises the authenticated encryption by returning any remaining buffered
 * ciphertext and the authentication tag.
 *
 * Optionally it can also provide the total ciphertext bytes generated during
 * this session. This is equal to the total plaintext bytes, but for streaming
 * data with unknown length in advance, the encryption session keeps track of
 * the total encrypted bytes.
 *
 * It will securely erase the content of the \p ctx struct before returning.
 *
 * The calling order is:
 * 1. init (once only)
 * 2. associated data update (0 or more times)
 * 3. encryption update (0 or more times, see warning)
 * 4. final (once only)
 *
 * @warning
 * Using the AEAD encryption to just authenticate any associated data with no
 * plaintext at all to be encrypted is not recommended for security reasons.
 * Instead use the Ascon hashing or xof functions in the form
 * `H(key || nonce || msg)`.
 *
 * @warning
 * A copy of the secret key is kept in the \p ctx struct and securely erased
 * during the ascon_aead128_encrypt_final() call. In case the encryption
 * session is interrupted and never finalised, clear the context with
 * `memset(&ctx, 0, sizeof(ascon_aead_ctx_t));` to erase the key copy.
 *
 * @param[in, out] ctx the encryption context, handling the cipher state
 *       and buffering of incoming data to be processed. It will be erased
 *       securely before this function returns. Not NULL.
 * @param[out] ciphertext trailing encrypted plaintext still available in the
 *       buffer of the buffered absorption. This function will write
 *       [0, #ASCON_RATE - 1] bytes into \p ciphertext.
 *       The exact number of written bytes is indicated by the return value.
 *       Not NULL.
 * @param[out] total_ciphertext_len sum of all ciphertext bytes generated by
 *       all update calls and this final call of this encryption session.
 *       It's the same as the sum of all plaintext bytes. May be NULL,
 *       if the sum is not of interest.
 * @param[out] tag Message Authentication Code (MAC, a.k.a. cryptographic tag,
 *       fingerprint), used to validate the integrity and authenticity of the
 *       associated data and ciphertext.
 * @returns number of bytes written into \p ciphertext. The value is in the
 *        interval [0, #ASCON_RATE - 1], i.e. whatever remained in the buffer
 *        afte the last update call.
 */
size_t ascon_aead128_encrypt_final(ascon_aead_ctx_t* ctx,
                                   uint8_t* ciphertext,
                                   uint64_t* total_ciphertext_len,
                                   uint8_t tag[ASCON_AEAD_TAG_LEN]);

// Tag must support ASCON_AEAD_TAG_LEN bytes
// Plaintext must support ciphertext_len bytes
// This function fails if the tag is invalid
ascon_tag_validity_t
ascon_aead128_decrypt(uint8_t* plaintext,
                      const uint8_t key[ASCON_AEAD_KEY_LEN],
                      const uint8_t nonce[ASCON_AEAD_NONCE_LEN],
                      const uint8_t* assoc_data,
                      const uint8_t* ciphertext,
                      const uint8_t tag[ASCON_AEAD_TAG_LEN],
                      size_t assoc_data_len,
                      size_t ciphertext_len);

// Generates [0, ciphertext_len] plaintext bytes
// Returns # of plaintext bytes generated
size_t ascon_aead128_decrypt_update(ascon_aead_ctx_t* ctx,
                                    uint8_t* plaintext,
                                    const uint8_t* ciphertext,
                                    size_t ciphertext_len);

// Generates [0, ASCON_RATE - 1] plaintext bytes
// Returns # of plaintext bytes generated
// total_plaintext_len could be NULL
size_t ascon_aead128_decrypt_final(ascon_aead_ctx_t* ctx,
                                   uint8_t* plaintext,
                                   uint64_t* total_plaintext_len,
                                   ascon_tag_validity_t* tag_validity,
                                   const uint8_t* tag);

void ascon_hash(uint8_t* digest, const uint8_t* data, size_t data_len);

void ascon_hash_init(ascon_hash_ctx_t* ctx);

void
ascon_hash_update(ascon_hash_ctx_t* ctx, const uint8_t* data, size_t data_len);

void ascon_hash_final(ascon_hash_ctx_t* ctx, uint8_t* digest);

void ascon_hash_xof(uint8_t* digest,
                    const uint8_t* data,
                    size_t digest_len,
                    size_t data_len);

void ascon_hash_init_xof(ascon_hash_ctx_t* ctx);

void ascon_hash_final_xof(ascon_hash_ctx_t* ctx,
                          uint8_t* digest,
                          size_t digest_len);

#ifdef __cplusplus
}
#endif

#endif  /* ASCON_H */
